package com.google.jenkins.plugins.persistentmaster;

import java.io.IOException;
import java.nio.file.DirectoryStream;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.HashSet;
import java.util.Set;
import java.util.logging.Logger;

/**
 * TODO: Insert description here. (generated by ckerur)
 */
public class FileTreeVisitor extends SimpleFileVisitor<Path>{
  private Path fromPath;
  public Set<String> fileNames = new HashSet<>();
  private static final Logger logger =
      Logger.getLogger(FileTreeVisitor.class.getName());
  Set<Path> excludedDirs = new HashSet<>();

  
  public FileTreeVisitor(Path fromPath) {
    this.fromPath = fromPath;
    // exclude tmp dirs from build slaves
    excludedDirs.add(fromPath.resolve("container-tmp"));
    excludedDirs.add(fromPath.resolve("garbage"));
    // exclude files and directories used by the backup/restore system
    excludedDirs.add(fromPath.resolve("backup-tmp"));
    excludedDirs.add(fromPath.resolve(".restore.log"));
    // exclude system dirs not used by Jenkins
    excludedDirs.add(fromPath.resolve("lost+found"));
    // exclude the maven repo (gets quite big!)
    excludedDirs.add(fromPath.resolve(".m2"));
    // exclude workspaces
    excludedDirs.add(fromPath.resolve("workspace"));
    // exclude war file contents
    excludedDirs.add(fromPath.resolve("war"));
    // exclude workspaces inside of branches
    excludedDirs.add(fromPath.resolve("jobs/*/branches/*/workspace"));
}
  
  public Set<String> getFileNamesInPath(){
    return fileNames;
  }

  @Override
  public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
    if (excludedDirs.contains(dir)) {
      logger.info("****Skipping dir****" +dir);
      return FileVisitResult.SKIP_SUBTREE;
    }
    if (attrs.isSymbolicLink()) {
      //Don't care about sym links
      return FileVisitResult.SKIP_SUBTREE;
    }   
    // check for an empty directory, because in that case we must
    // explicitly add that to our list
    try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(dir)) {
      if (!directoryStream.iterator().hasNext()) {
        fileNames.add(fromPath.relativize(dir).toString());
      }
    } // auto-close directoryStream
      return FileVisitResult.CONTINUE;
  }

  @Override
  public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
    if(attrs == null) {
        attrs = Files.readAttributes(file, BasicFileAttributes.class);
    }
    if (attrs.isSymbolicLink()) {
      fileNames.add(fromPath.relativize(file).toString());
      return FileVisitResult.SKIP_SUBTREE;
    } 
      fileNames.add(fromPath.relativize(file).toString());
      logger.info(fromPath.relativize(file).toString());
      return FileVisitResult.CONTINUE;
  }
  
  @Override
  public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {
    if (excludedDirs.contains(file)) {
      return FileVisitResult.SKIP_SUBTREE;
    }
    return super.visitFileFailed(file, exc);
  }

}

